# OS Lab 3

> Contributors：焦心雨(2112536)、李艺楠(2110246)、辛浩然(2112514)
>
> - 包括练习的内容；
>
> - Challenge (LRU) 在单独的 Design_Doc 中。
>
> [GitHub链接](https://github.com/Herren-Hsing/Operation-System)

## 练习一：理解基于FIFO的页面替换算法(思考题)

描述FIFO页面置换算法下，一个页面从==被换入到被换出==的过程中，会经过代码里哪些函数/宏的处理(或者说，需要调用哪些函数/宏)，并用简单的一两句话描述每个函数在过程中做了什么？(为了方便同学们完成练习，所以实际上我们的项目代码和实验指导的还是略有不同，例如我们将FIFO页面置换算法头文件的大部分代码放在了`kern/mm/swap_fifo.c`文件中，这点请同学们注意)

- 至少正确指出10个不同的函数分别做了什么？如果少于10个将酌情给分。我们认为只要函数原型不同，就算两个不同的函数。要求指出对执行过程有实际影响，删去后会导致输出结果不同的函数(例如assert)而不是cprintf这样的函数。如果你选择的函数不能完整地体现”从换入到换出“的过程，比如10个函数都是页面换入的时候调用的，或者解释功能的时候只解释了这10个函数在页面换入时的功能，那么也会扣除一定的分数

### (一)问题作答

由于在一个页面从==被换入到被换出==的过程中所调用的函数或宏众多，因此此处仅选择一些处于核心地位的函数展示：

#### (1)页面置换类函数/宏：

1. `swap_in(struct mm_struct *mm, uintptr_t addr, struct Page **ptr_result)`

   用于页面换入，首先为要加载的页面分配一个页面帧结构，之后调用`get_pte()`获取虚拟地址 `addr `对应的页表项指针，成功后从磁盘中读取交换页入分配的页面帧结构。

2. `swap_out(struct mm_struct *mm, int n, int in_tick)`

   用于页面换出，选择一个要交换出的页面后，将页面内容写入磁盘的交换区域，同时更新相应的页表项。

3. `swap_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)`

   用于将一个页面标记为可置换的。

4. `_fifo_swap_out_victim(struct mm_struct *mm, struct Page **ptr_page, int in_tick)`

   FIFO算法中选择换出页面的具体方法，从页面置换算法队列(`pra_list_head`)的前面取下最早到达的页面作为换出页面，如果为空则返回NULL。

5. `_fifo_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)`

   FIFO算法中标记页面可置换的具体方法，将最近到达的页面链接到页面置换算法队列(`pra_list_head`)的末尾。

#### (2)页表处理类函数/宏：

1. `set_page_ref(page, 1)`

   在创建页目录项时，将页面的引用次数置一。

2. `page_ref_dec(page) `

    减少页面的引用计数

3. `page_ref_inc(page)`

    增加页面的引用计数

4. `pte_create()`

   创建页表项

5. `get_pte(pde_t *pgdir, uintptr_t la, bool create)`

​	获取页表项(`pte`)，并返回此`pte`的内核虚拟地址。如果包含此`pte`的页表不存在，则为页表分配一页。在换出时获取要换出的那一页的页表项，在换入时获取为即将调入的页面所分配的页面的页表项。

6. `page_remove_pte(pde_t *pgdir, uintptr_t la, pte_t *ptep)`

​	释放与线性地址` la `相关的 `Page `结构，并清除或使无效与线性地址` la` 相关的页表项 `pte`

7. `pgdir_alloc_page(pde_t *pgdir, uintptr_t la, uint32_t perm)`

​	调用` alloc_page` 和` page_insert` 函数来分配一个页面大小的内存，并建立地址映射

#### (3)页面处理类函数/宏：

1. `page_insert(pde_t *pgdir, struct Page *page, uintptr_t la, uint32_t perm)`

   建立物理地址与线性地址 `la` 的映射，将加载回的页面与页表建立新的映射

2. `alloc_pages(size_t n)`

   调用` pmm->alloc_pages` 分配连续的 n 个页面内存

3. `free_pages(struct Page *base, size_t n)`

   建立映射失败后使用`free_page()`释放之前分配的页面结构体

4. `swap_map_swappable(mm, addr, page, 1)`

   将页面标志设置为可交换。

5. `_fifo_map_swappable()`  

   FIFO算法中将页面标志设置为可交换的具体方法是使用`list_add(head, entry)`将最近到达的页面链接到页面置换算法队列`(pra_list_head)`的末尾

#### (4)缺页异常类

1. `exception_handler()` 

   用于处理不同类型的异常

2. `pgfault_handler(tf)`

   发生缺页异常后调用的处理函数

3. `do_pgfault(check_mm_struct, tf->cause, tf->badvaddr)`

   实际上最核心的缺页异常处理函数

#### (5)链表功能类函数/宏：

1. `list_prev(head)`:

   获取队列的最前端，即最早被访问的页面。

2. `list_add(head, entry)`:

   将页面链接到FIFO队列的末尾，表示该页面最近被访问。

3. `list_del(entry):`

   将页面从FIFO队列中移除。

4. `list_next(le)`

   用于寻找链表的下一个指针，在`find_vma`函数中用于遍历

#### (6)磁盘读写类：

1. `swapfs_read(swap_entry_t entry, struct Page *page)`

   从磁盘中读取数据，并将数据复制到给定的页面中，用于页面换入时将磁盘上的页上的数据复制到新创建的页面上。

2. `swapfs_write(swap_entry_t entry, struct Page *page)`

   将页面中的数据写入磁盘，用于页面换出时将页上的数据写入磁盘。

#### (7)类型转化类

1. `le2vma(le, list_link)`

   将链表指针转化为vma_struct结构

2. `page2pa(struct Page *page)`

   获取某一个页面的物理页的起始地址

3.  `page2ppn(struct Page *page)` 

   获取某一个页面的物理页号

4. `pte2page(pte_t pte)`

   将页表项结构转化为页面结构

#### (8)地址转换类

1. `KADDR(pa)`

   将物理地址转换为内核虚拟地址

2. `PDX1(la)`

   一级页表项

3. `PTE_ADDR(pte)` 

   读取页表项里存储的地址

#### (9)其他函数

1. `local_intr_save(intr_flag)`

   保存当前中断状态

2. `local_intr_restore(intr_flag)`

    恢复中断状态

3. `tlb_invalidate()`

   刷新TLB

### (二)分析过程：

在Lab3的框架中支持系统的消极换出策略。消极换出策略是指只有当试图得到空闲页时，发现当前没有空闲的物理页可供分配，这时才开始查找“不常用”页面，并把一个或多个这样的页换出到硬盘上。

当试图得到空闲页失败时会触发一个异常，CPU首先会将当前的错误原因 (`tf->cause`) 和错误地址 (`tf->badvaddr`)保存起来并跳转到相应的异常入口点 `__alltraps`，保护所有寄存器到栈顶，然后调用`trap`异常处理函数。页访问异常的处理是在其中的`exception_handler()`函数里进行的，我们从这里开始分析页面是如何被换入换出的，以下是`exception_handler()`调用到的函数/宏：

```C
├── exception_handler()  // 用于处理不同类型的异常
│   ├── #define CAUSE_LOAD_PAGE_FAULT 0xd  // 加载异常
│   ├── #define CAUSE_STORE_PAGE_FAULT 0xf // 写入异常
│   │   ├── pgfault_handler(tf)  // 发生缺页异常后调用的处理函数
│   │   │   ├──  do_pgfault(check_mm_struct, tf->cause, tf->badvaddr)  //  缺页异常处理函数
```

发生缺页异常后，与缺页异常相关的有`CAUSE_LOAD_PAGE_FAULT`和`CAUSE_STORE_PAGE_FAULT`两个类型。解决这两种异常都需要调用`pgfault_handler(tf)`处理缺页异常。

在`pgfault_handler(tf)`函数中，首先会引入当前使用的`mm_struct`的指针，初步检查该指针不为空后就将处理任务分发给函数`do_pgfault(check_mm_struct, tf->cause, tf->badvaddr)`处理，实际上`do_pgfault` 函数是处理页面故障的核心函数，它的函数调用如下：

```C
├──  do_pgfault(check_mm_struct, tf->cause, tf->badvaddr)//缺页异常处理函数
│   ├── find_vma(mm, addr);//寻找某个虚拟地址是否在内存中
│   ├── 设定权限：页表项：PTE_U、PTE_R、PTE_W；内存标志位：VM_WRITE
│   ├── ROUNDDOWN(addr, PGSIZE)//将地址向下对齐到页面大小的边界
│   ├── get_pte(mm->pgdir, addr, 1) //尝试获取页面错误地址对应的页表项
│   ├── pgdir_alloc_page(mm->pgdir, addr, perm)
│   ├── swap_in(mm, addr, &page)
│   ├── page_insert(mm->pgdir, page, addr, perm)
│   ├── swap_map_swappable(mm, addr, page, 1)
```

`do_pgfault `函数的第三个参数是导致内存访问异常的地址，首先他会调用` find_vma(mm, addr)`在当前使用的`mm_struct`内存管理器中搜寻该虚拟地址是否在所管理的虚拟内存范围内，即虚拟地址对应的VMA是否存在。

- ```C
   ├── find_vma(mm, addr); // 寻找某个虚拟地址是否合法
   │   ├── list_next(le) // 遍历vma_struct时找到下一个链表指针
   │   ├── le2vma(le, list_link) // 将链表指针转化为vma_struct结构
   ```
- `find_vma()`函数能够在一个`mm_struct`维护的链表中扫描所有的`vma_struct`，判断指定的地址`addr`是否在其中任意一个`vma_struct`中。`find_vma()`函数首先会使用缓存的 `vma `结构体`mmap_cache`来加速查找该虚拟地址。如果没有找到则会使用`list_next(le)`遍历`vma_struct`结构体链表`mmap_list`，使用`le2vma(le, list_link)`函数将其中每一个链表指针转化为`vma_struct`结构体，并且判断`addr`是否存在于`vma_struct`中，如果找到了则将该地址所在的`vma_struct`结构体设置为缓存结构体，并返回该结构体；如果未找到则返回NULL，说明查询的虚拟地址不存在/不合法，既不对应内存里的某个页，也不对应硬盘里某个可以换进来的页。

如果该地址是合法的，那么我们就需要为它**构造一个页表项**，并根据所在VMA的读写权限使用一些PTE_U、PTE_R、PTE_W等宏设置好页面权限。因此，接下来使用 `ROUNDDOWN(addr, PGSIZE)`函数将地址向下对齐到页面大小的边界，尝试使用`get_pte()`函数**寻找该页面错误地址对应的页表项**。

- 在`get_pte()`中，首先我们从根页目录表利用`PDX1(la)`找到对应的Giga Page。如果下一级页表不存在，那就使用`alloc_page()`给它分配一页。

- ```C
  ├── get_pte(mm->pgdir, addr, 1)  // 尝试获取页面错误地址对应的页表项
  │   ├── PDX1(la) // 获取页目录索引
  │   ├── alloc_page() // 分配页面
  │   ├── set_page_ref(page, 1) // 将该物理页帧的引用设置为1
  │   ├── page2pa(page)//
  │   ├── memset(KADDR(pa), 0, PGSIZE)    
  │   ├── pte_create(page2ppn(page), PTE_U | PTE_V)
  │   │   ├── page2ppn(page)
  ```

- 所调用的`alloc_page()`是一个宏定义，调用分配一个页面的`alloc_pages()`函数。

  - ```C
    #define alloc_page() alloc_pages(1)
    ├── alloc_page() // 专门用于分配一个页面的宏
    │   ├── alloc_pages(n) // 分配n个页面的宏
    │   │   ├── local_intr_save(intr_flag) // 保存当前的中断状态
    │   │   ├── pmm_manager->alloc_pages(n)// 从物理内存管理器分配 n 个页面
    │   │   ├── local_intr_restore(intr_flag)// 恢复中断状态
    │   │   ├── swap_out(check_mm_struct, n, 0)// 如果此时试图得到空闲页且没有空闲的物理页时，页面换出

  - 首先先使用`local_intr_save(intr_flag)`保存当前的中断状态，然后调用在Lab2中编写的页面管理器的`alloc_pages(n) ` 函数分配页面，恢复中断状态后，由于只需要分配一个页面，因此分配成功后就直接返回。

  - 如果分配页面时试图得到空闲页且没有空闲的物理页时，**尝试换出页面到硬盘上**。具体换出在后面分析。

- 获取到对应的页面后，使用`set_page_ref(page, 1)`将该物理页帧的引用设置为1。我们将分配到的页面的物理地址清空，并调用`pte_create()`函数创造一个页表项。

- 之后继续在二级页目录表寻找页表项，如果不存在下一级页表，继续创建一个新的页表。

- 最终返回输入的虚拟地址`la`对应的页表项的地址。得到页表项后，回到`do_pgfault()`中。

得到的页表项可能是**新创建的页表项**，也可能是**描述虚拟内存与磁盘位置的页表项**。因此需要分别进行处理。

如果对应页表项的内容每一位都全为0，说明**页表项之前并不存在**，需要设置对应的数据，进行线性地址与物理地址的映射。调用`pgdir_alloc_page()`函数<u>**分配一个页面大小的内存，并建立地址映射**</u>。

- ```C
   ├── pgdir_alloc_page()// 分配一个页面大小的内存，并建立地址映射
   │   ├── alloc_page()//分配一个页面大小的内存
   │   ├── page_insert(pgdir, page, la, perm)//该页面映射到线性地址 la
   │   ├── free_page(page)//释放之前分配的页面结构体
   │   ├── swapfs_write()//将数据写入磁盘中
   │   ├── swap_map_swappable(check_mm_struct, la, page, 0)//标记页面为可交换的
   │   ├── assert(page_ref(page) == 1) //确保页面的引用计数为 1 
   ```

- 首先调用`alloc_page`分配页面。如果<u>分配页面时试图得到空闲页且没有空闲的物理页时，需要换出页面到硬盘上</u>。

- 当分配好页面后，我们需要调用`page_insert`函数将该页面映射到线性地址` la`。

  - ```c
    ├── page_insert(pgdir, page, la, perm)// 建立物理地址与线性地址 la 的映射，将加载回的页面与页表建立新的映射
    │   ├── get_pte(pgdir, la, 1)
    │   ├── page_ref_inc(page)//指向这个物理页面的虚拟地址增加一个
    │   ├── pte2page(*ptep)//将页表项结构转化为页面结构
    │   ├── page_ref_dec(page)//指向这个物理页面的虚拟地址减少一个
    │   ├── page_remove_pte(pgdir, la, ptep)//标记页面为可交换的
    │   ├── pte_create(page2ppn(page), PTE_V | perm) //构造页表项
    │   ├── tlb_invalidate(pgdir, la)//刷新TLB
    ```

  - 首先使用`get_pte()`找到对应页表项的位置，使用`age_ref_inc(page)`函数将指向这个物理页面的虚拟地址增加一个。

  - 如果页表项中原先存在映射，先使用`pte2page()`将页表项结构转化为页面结构，如果转化后就是我们要修改的对应物理页面，那么使用`page_ref_dec(page)`复原我们刚刚的增加操作；

  - 如果原先这个虚拟地址映射到其他物理页面，那么需要删除映射。

  - 之后我们使用`pte_create()`构造一个页表项，将页表项的内容设置为新的值，以建立虚拟地址`la`到物理页面`page`的映射关系。同时，设置相应的权限标志`perm`。这样，现在虚拟地址`la`已经成功映射到了物理页面`page`。并且使用`tlb_invalidate()`刷新页表保存。

- 如果建立映射失败，我们就使用`free_page()`释放之前分配的页面结构体。释放与创建相类似，此处不再赘述，仅给出调用关系：

  - ```c
    #define alloc_page() alloc_pages(1)
    ├── free_page(page)//用于释放页面的宏
    │   ├── free_pages(page, 1)//释放n个页面的函数
    │   │   ├── local_intr_save(intr_flag)//保存当前的中断状态
    │   │   ├── pmm_manager->free_pages(base, n)//从物理内存管理器释放 n 个页面
    │   │   ├── local_intr_restore(intr_flag)//恢复中断状态
    ```

- 如果映射建立成功且开启了页面交换，并使用 `swap_map_swappable(check_mm_struct, la, page, 0)`标记页面为可交换的，加入虚拟内存交换管理器的管理，并使用`assert(page_ref(page) == 1) `确保页面的引用计数为 1 。

如果对应页表项的内容每一位不全为0，说明**页面数据之前被交换到了磁盘中，需要换回内存**。

- 调用`swap_in()`将我们<u>想要换入的页面换入到内存</u>当中。

  ```C
  ├── swap_in(mm, addr, &page)
  │   ├── alloc_pages(1)
  │   ├── get_pte(mm->pgdir, addr, 0)
  │   ├── swapfs_read((*ptep), result)
  │   │   ├── ide_read_secs()
  │   ├── assert(r != 0)
  ```

  - 首先，调用`alloc_pages`分配一个空闲页。

    - 在分配页面时，<u>如果分配页面时试图得到空闲页且没有空闲的物理页时，需要调用`swap_out`换出页面到硬盘上</u>。

    - ```c
      ├── swap_out()//页面换出
      │   ├── swap_out_victim(1)//找出一个需要换出的页面
      │   │   ├──  _fifo_swap_out_victim()//调用fifo算法中相关的函数
      │   ├── get_pte()
      │   ├── swapfs_write()//将页面中的数据写入磁盘
      │   │   ├── ide_write_secs()//将页面中的数据写入磁盘
      │   ├── map_swappable()
      │   │   ├── _fifo_map_swappable()  
      │   │   │   ├── list_add(head, entry)
      │   ├── tlb_invalidate()//刷新TLB
      ```

    - `swap_out()`函数首先会调用管理器的<u>` swap_out_victim `函数，选择一个要交换出的页面</u>，并将结果保存在 `page `中。

      - 在我们编写的FIFO函数中，`_fifo_swap_out_victim()`函数会先获取页面置换算法所需的队列头并确保不为零。之后获取最早到达的页面并将将该页面的地址设置给` ptr_page` 指针。

    - 当获取到我们需要换出的页面后，我们会调用`get_pte()`函数获取它的页表项并确保有效。之后调用` swapfs_write` 函数将页面内容写入磁盘的交换区域。

      - 使用swapfs_write()函数写入磁盘中：

        ```C
        ├── swapfs_write()//将页面中的数据写入磁盘
        │   ├── ide_write_secs()//将页面中的数据写入磁盘
        ```

    - 如果`ide_write_secs()`能够写入成功，就调用`map_swappable()`更新相应的页表项标记页面为可交换。

      - 在我们实现的`_fifo_map_swappable() `页面置换算法中，会使用`list_add(head, entry)`将最近到达的页面链接到页面置换算法队列`(pra_list_head)`的末尾。

    - 最后刷新一下TLB更新页面状态，页面换出就完成了。

  - 使用`get_pte()`读取页表项所在地址，根据页表项使用`swapfs_read()`从磁盘上读取数据，并将数据复制到给定的页面中。

  - ```c
    ├── swapfs_read()//将页面中的数据写入磁盘
    │   ├── ide_read_secs()//将页面中的数据写入磁盘
    ```

  - 最后使用一个断言确保读取操作成功，并将加载后的页面帧结构保存到` ptr_result` 指针指向的位置返回结果。

- 换入成功后，调用`page_insert`建立该页面确实的物理地址与分配得到的页面之间的线性关系(并刷新TLB)，并调用`swap_map_swappable`标记页面为可交换的，加入虚拟内存交换管理器的管理。

至此，一整个缺页异常的处理过程就完整结束了。

## 练习二：深入理解不同分页模式的工作原理(思考题)

`get_pte()`函数(位于`kern/mm/pmm.c`)用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。

- `get_pte()`函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。
- 目前`get_pte()`函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？

### (一)问题一

**(1)get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。**

首先我们先对`get_pte()`函数中这两段形式类似的代码进行分析：

第一段代码：

```C
pde_t *pdep1 = &pgdir[PDX1(la)];
//pgdir是根页目录表
//PDX(la) = 虚拟地址la的一级页目录项索引。
//pdep1指向线性地址la的一级页目录表项
if (!(*pdep1 & PTE_V)) {// 如果一级页目录表项不存在或无效
    struct Page *page;//分配一个新的物理页
    if (!create || (page = alloc_page()) == NULL) {
        // 如果不需要创建或者分配页面失败
        return NULL;//返回NULL
    }
    set_page_ref(page, 1);//将页面的引用次数置一
    uintptr_t pa = page2pa(page);//获取由此page管理的内存的物理地址
    memset(KADDR(pa), 0, PGSIZE);//将对应的物理地址指向的内存区域清零
    *pdep1 = pte_create(page2ppn(page), PTE_U | PTE_V);//创建页表项，初始化为指向这个物理页的地址，标记为用户可访问(PTE_U)和有效(PTE_V)
}
```

第二段代码：

```C
pde_t *pdep0 = &((pde_t *)KADDR(PDE_ADDR(*pdep1)))[PDX0(la)];
//PDE_ADDR(*pdep1)将页表项里存储的地址取出
//KADDR(PDE_ADDR(*pdep1))将物理地址转换为内核虚拟地址
//PDX0(la)= 虚拟地址la的二级页目录项索引
//((pde_t *)KADDR(PDE_ADDR(*pdep1)))[PDX0(la)]是二级页目录表项
if (!(*pdep0 & PTE_V)) {// 如果二级页目录表项不存在或无效
    struct Page *page;//分配一个新的物理页
    if (!create || (page = alloc_page()) == NULL) {
       // 如果不需要创建或者分配页面失败
        return NULL;//返回NULL
    }
    set_page_ref(page, 1);//将页面的引用次数置一
    uintptr_t pa = page2pa(page);//获取由此page管理的内存的物理地址
    memset(KADDR(pa), 0, PGSIZE);//将对应的物理地址指向的内存区域清零
    *pdep0 = pte_create(page2ppn(page), PTE_U | PTE_V);//创建页表项，初始化为指向这个物理页的地址，标记为用户可访问(PTE_U)和有效(PTE_V)
}
```

这两段相似的代码的功能分别是在处理一个虚拟地址时，判断一级页表和二级页表中的页目录表项是否存在，如果不存在就创建新页目录表项并初始化为新分配的物理页，并设置相应的标志位.

SV39中的虚拟地址结构如下：

| VPN[2] | VPN[1] | VPN[0] | PGOFF |
| :----: | :----: | :----: | :---: |
|   9    |   9    |   9    |  12   |

物理地址如下：

| PPN[2] | PPN[1] | PPN[0] | PGOFF |
| :----: | :----: | :----: | :---: |
|   26   |   9    |   9    |  12   |

其页表项结构如下：

| PPN[2] | PPN[1] | PPN[0] | 保留位 |  D   |  A   |  G   |  U   |  X   |  W   |  R   |  V   |
| :----: | :----: | :----: | :----: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|   26   |   9    |   9    |   2    |  1   |  1   |  1   |  1   |  1   |  1   |  1   |  1   |

Sv48的虚拟地址结构与SV39相类似，只不过使用了四级页表因此增加了9位来表示虚拟地址：

| VPN[3] | VPN[2] | VPN[1] | VPN[0] | PGOFF |
| :----: | :----: | :----: | :----: | :---: |
|   9    |   9    |   9    |   9    |  12   |

物理地址如下：

| PPN[3] | PPN[2] | PPN[1] | PPN[0] | PGOFF |
| :----: | :----: | :----: | :----: | :---: |
|   17   |   9    |   9    |   9    |  12   |

页表项如下：

| PPN[3] | PPN[2] | PPN[1] | PPN[0] | 保留位 |  D   |  A   |  G   |  U   |  X   |  W   |  R   |  V   |
| :----: | :----: | :----: | :----: | :----: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|   17   |   9    |   9    |   9    |   2    |  1   |  1   |  1   |  1   |  1   |  1   |  1   |  1   |

在虚拟地址与物理地址互转时，他们都是**<u>相同的逻辑进行映射</u>**：

以SV39为例：

**首先从satp寄存器得到PGD的物理地址，结合VPN找到PMD；找到PMD后，再结合VPN[1]找到PTE，然后结合VPN[0]得到VA在PTE索引中的值，从而得到物理地址。**

最后在PTE中取出PPN[2]、PPN[1]和PPN[0]，再和虚拟地址的低12位offset相加，得到最终的物理地址。

在**页表结构上也使用同样的存储方式**：

每一个页表项是8KiB，一个页的大小为4KB，因此一个根目录表中能够存放512个一级页表的页表项，而512个页表项恰好可以由9位的PPN索引。一个一级页表的页目录表中能够存放512个二级页表项，一个二级页表的页目录表中能够存放512个三级页表项。一级页目录表与二级页目录表的结构几乎相同，因此代码的逻辑结构也基本相同。

SV48在逻辑上与SV39的页表映射相类似，代码结构也相同。除此之外还有对应五级页表的Sv57也与之类似。

Sv32适用于32位系统，因此地址结构略微有些变化。

Sv32的虚拟地址结构如下：

| VPN[1] | VPN[0] | PGOFF |
| :----: | :----: | :---: |
|   10   |   10   |  12   |

物理地址如下：

| PPN[1] | PPN[0] | PGOFF |
| :----: | :----: | :---: |
|   12   |   10   |  12   |

其页表项结构如下：

| PPN[1] | PPN[0] | 保留位 |  D   |  A   |  G   |  U   |  X   |  W   |  R   |  V   |
| :----: | :----: | :----: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|   12   |   10   |   2    |  1   |  1   |  1   |  1   |  1   |  1   |  1   |  1   |

在Sv32中，支持4GiB的虚址空间，这些空间被划分为2^10 个4KiB大小的基页。页表项的大小为4B，那么一个页中能够存放1024个页表项，刚好可以由10位PPN索引。在Sv32中变化为10位索引的两级页面查找，但由于Sv32中的页表的大小和每个页的大小也是完全相同的，因此在逻辑上仍然与Sv39和Sv48类似。

### (二)问题二

**(2)目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？**

在我们实现的页面置换算法中，我认为这是可以接受的。

当两个功能合并在同一个函数中时，如果查找一个页表项时包含此pte的页表不存在，那么这函数就会自动地为页表分配一页并返回，只有在分配失败时函数返回才是错误的。

如果拆开后，可能需要拆分为`pte_find()`函数与`pte_new()`函数。`pte_find()`函数用于帮助我们找到一个页表项，如果找到了就返回页表项的地址；失败就返回NULL。

在我们的程序中，有三处调用了`get_pte()`函数。一是在`do_pgfault`中，我们需要获取页面错误地址对应的页表项；二是在`swap_out`中，我们需要获取被换出页面的页表项；三是在`swap_in`需要获取我们为即将调入的数据所分配的页面的页表项。在这三处中，我们调用`get_pte()`函数的目的都是希望得到一个页表项的地址，无论是找到已经存在的或者是操作系统为其重新创建的，而不是仅仅调用`pte_find()`函数后返回NULL值后不做任何处理。

因此，还需要对`pte_find`函数的错误情况再去调用`pte_new`函数创建页表项。而失败的情况是多样的，可能第一级页表项不存在，也可能第二级页表项不存在，需要根据这个函数的返回结果去判断是否需要新建和新建哪一级页表项，在`pte_new()`函数完成页表的内存分配以及页表项的创建。最终才能得到最后一级的页表项。拆开之后的情况判断和处理无疑是复杂的。

此外，是否将功能拆开，还涉及到代码复用与调用开销权衡的问题。虽说将分配拆分出来作为独立的函数能够有利于维护，但是频繁的函数调用会增大调用开销。拆分后实际上也并没有减少要执行的指令数，反而由于函数调用增大了开销。如果一个虚拟地址对应的第二级页表和第三级页表都不存在，需要频繁地调用函数，需要函数调用等系统开销，反而浪费了资源。

综上，在我们实现的简易页面置换算法中，我认为没有必要将两个功能拆开。

## 练习三：给未被映射的地址映射上物理页(需要编程)

> 补充完成`do_pgfault`(`mm/vmm.c`)函数，给未被映射的地址映射上物理页。设置访问权限的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制结构所指定的页表，而不是内核的页表。 请在实验报告中简要说明你的设计实现过程。请回答如下问题：
>
> - 请描述页目录项(Page Directory Entry)和页表项(Page Table Entry)中组成部分对ucore实现页替换算法的潜在用处。
> - 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
> - 数据结构`Page`的全局变量(其实是一个数组)的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？

### 实现 `do_pgfault`

`do_pgfault`是处理`page fault`的异常处理函数。这个函数的主要工作就是把被换进硬盘里的数据再换回来。

1. 首先判断页面错误地址是否是程序会访问到的地址，也就是是否在一个记录过的 VMA 的范围内。

2. 然后，构造需要设置的缺页页表项的权限：根据 VMA 的属性，构造需要设置的页表项的权限 `perm`。如果 VMA 允许写入，`perm` 包括可读和可写权限。

   ```c
   // 构造需要设置的缺页页表项的perm权限
   uint32_t perm = PTE_U;
   
   // 如果 VMA 允许写入，则设置页面权限位
   if (vma->vm_flags & VM_WRITE)
   {
       perm |= (PTE_R | PTE_W);  // 将 perm 的权限标志设置为同时包括可读和可写权限
   }
   ```

3. 接下来，将地址向下对齐到页面大小的边界，尝试获取页面错误地址对应的页表项，如果页表项不存在，则创建一个。

4. 如果页表项为空，说明之前页表项并不存在，需要调用`pgdir_alloc_page`分配物理页面并进行线性地址与物理地址的映射，并设置页表项有效位 V；

5. 如果页表项不为空，表示之前的页面被交换到磁盘上。在这种情况下，如果开启了交换磁盘虚拟内存机制，会将页面从磁盘交换回物理内存，并重新建立映射。

   - **从磁盘加载页面**：首先调用 `swap_in` 函数，将位于磁盘上的页面数据交换回物理内存中。

     ```c
     if ((ret = swap_in(mm, addr, &page) != 0))
     {
         // swap_in 返回值不为0，表示换入失败
         goto failed;
     }
     ```

   - **页面加载成功处理**：如果 `swap_in` 函数返回0，表示页面成功加载回物理内存。接下来调用`page_insert`函数将加载回的页面与页表建立新的映射。映射时操作内存控制结构所指定的页表。

     ```c
     page_insert(mm->pgdir, page, addr, perm);
     ```

   - **管理可交换性**：为了继续跟踪该页面是否可交换，需要将页面添加到全局虚拟内存交换管理器的管理中。

     ```c
     swap_map_swappable(mm, addr, page, 1);
     ```

   - **更新页面的虚拟地址信息**：将物理页的虚拟地址信息更新。

     ```c
     page->pra_vaddr = addr;
     ```

### 问题回答

#### PDE & PTE

> 请描述页目录项(Page Directory Entry)和页表项(Page Table Entry)中组成部分对 ucore 实现页替换算法的潜在用处。

页表项结构如下，以Sv39为例：

```c
typedef uintptr_t pte_t; // 页表项	
typedef uintptr_t pde_t; // 页目录项
/*
Sv39 页表项(页目录表项)：
+----26---+----9---+----9---+---2----+-------8-------+
|  PPN[2] | PPN[1] | PPN[0] | 保留位  |D|A|G|U|X|W|R|V|
+---------+----+---+--------+--------+---------------+
*/
```

**页目录表**用于根据传入的线性地址**索引对应的页表**。在页面替换过程中，要想找到虚拟地址对应的页表项，肯定需要页目录表的索引。

- 页目录表项与页表项基本结构相同，但R、W、X位全为零，这三位能够**标识它是一个页目录表项**。
- 页目录项第 53-10 位共44位为一个物理页号，是虚拟地址对应的**下一级页表所在页的物理页号**。

页表项用于维护**页物理地址与虚拟地址的映射关系**。根据传入的虚拟地址，可以得到页帧的物理页号，进而得到物理地址。

- 页表项**最低位V 表示这个页表项是否有效**，在正常维护内存中的页的映射关系时，页表项是有效的。
- 页表项中的W、R位，设置了不同页面的访问权限，使映射更加精细。

为了能够在页替换时得到被置换出去的页的磁盘位置，在`ucore`中偷懒地复用**页表项描述被置换出去的物理页**，在这种情况下，它被用来**维护该物理页与磁盘上扇区的映射关系**。

```c
typedef pte_t swap_entry_t; 

/* 
 swap_entry_t
 --------------------------------------------
|         offset        |   reserved   | 0 |
 --------------------------------------------
          24 bits            7 bits    1 bit
 */
```

- 这时，为了能让MMU不将其解释为物理页映射，**<u>最低位V置0</u>**。
- 因此，当最低位V为0时，**页表项可以记录该虚拟页在磁盘中的位置**，为换入换出提供磁盘位置信息。
  - 在换入物理页时，根据页面错误地址，<u>在页表项中可以查找到页在磁盘的位置</u>，可将虚拟地址对应于磁盘的一页内容读入到内存中。
    - 然后将页表项修改为虚拟地址对物理地址的映射，并设置有效位，以标记其是一个有效映射。
    - 换入后，通过页表项中的W、R位的设置，能够设置页面的相关访问权限。
  - 在换出物理页时，当找到可以换出去的页面并得到所对应的虚拟地址后，将物理页写入磁盘，<u>再修改虚拟地址对应的页表项中所保存的映射关系和有效位</u>。

- 总之，通过**修改页表项中的映射关系和有效位**，可以实现页替换操作。

#### 页访问异常

> 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

产生异常后，CPU会保存当前错误原因 (`tf->cause`) 和错误地址 (`tf->badvaddr`)，跳转到相应的异常入口点 `__alltraps`：首先保护所有寄存器到栈顶，然后调用`trap`异常处理函数。

页访问异常的处理是在其中的`exception_handler()`函数里进行的。按照`scause`寄存器对异常的分类，有`CAUSE_LOAD_PAGE_FAULT` 和`CAUSE_STORE_PAGE_FAULT`两种情况。

对于读取和写入页面错误，会打印相应的消息，然后调用 `pgfault_handler` 函数(核心是调用`do_pgfault`函数)来处理页面错误，主要工作就是把被换进硬盘里的页面再换回来，处理过程在前面已经分析。如果处理失败，它会触发 `panic` 并显示相应的错误信息。

异常处理结束后，会恢复上下文与特权级，回到之前的状态，继续执行原本触发缺页异常的指令。

#### `Page` 数组

> 数据结构 `Page` 的全局变量(其实是一个数组)的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？

有关系。

- `Page`数组的每一项，记录了一个物理页的信息。

- 每个页目录项保存了下一级页表所在物理页的物理页号，每个页表项则保存了一个物理页的物理页号。

- 页目录项保存的物理页号以及页表项保存的物理页号都对应于`Page`数组所管理的某一页。

可以从页表项访问到管理其保存的页面的`Page`结构体，得到页面信息，也可以从页目录表项中得到下一级页表所在页的信息，即宏定义`pte2page`和`pde2page`，步骤是相同的：

- 取页表项(页目录表项)前44位并左移12位，得到页面的物理地址；
- 由物理地址得到物理页号，减去基数`nbase`，得到在`Page`数组里的偏移，即可访问到页结构体。

## 练习四：补充完成Clock页替换算法(需要编程)

通过之前的练习，相信大家对FIFO的页面替换算法有了更深入的了解，现在请在我们给出的框架上，填写代码，实现 Clock页替换算法(mm/swap_clock.c)。(提示:要输出curr_ptr的值才能通过make grade)

请在实验报告中简要说明你的设计实现过程。请回答如下问题：

- 比较Clock页替换算法和FIFO算法的不同。

### clock页替换算法思想

clock页替换算法需要实现在发生缺页时，将最早访问过的页面换出到磁盘上。其替换原则为：

1. 将内存中的页面通过链接指针链接为一个双向循环链表，每装入一个页面，将其插入到链表的尾部，且将其访问位设置为1。
2. 当需要淘汰页面时，只需要检查页的访问位。访问位为1，将其访问位置为0，暂不换出，继续检查下一个页面；访问位为0，选择此页换出。
3. 若第一轮扫描中所有页面访问位都是1，则将这些页面的访问位置为0后再进行第二轮扫描。第二轮扫描一定会有访问位为0的页面，因此将其换出。所以clock页面替换算法淘汰页面最多会经过两轮扫描。

### 代码实现

#### 1.` _clock_init_mm`进行初始化工作

在`_clock_init_mm`函数中需要初始化内存管理结构 `mm` 的时钟置换算法所需的数据结构：

```c
static int
_clock_init_mm(struct mm_struct *mm)
{     
     /*LAB3 EXERCISE 4: YOUR CODE*/ 
     // 初始化pra_list_head为空链表
     // 初始化当前指针curr_ptr指向pra_list_head，表示当前页面替换位置为链表头
     // 将mm的私有成员指针指向pra_list_head，用于后续的页面替换算法操作
     //cprintf(" mm->sm_priv %x in fifo_init_mm\n",mm->sm_priv);
    list_init(&pra_list_head);
    curr_ptr = &pra_list_head;
    mm->sm_priv = &pra_list_head;
    return 0;
}
```

主要执行以下操作：

- 初始化链表头 `pra_list_head`，表示待置换的页面链表。
- 将全局指针 `curr_ptr` 设置为链表头 `pra_list_head`，用于跟踪链表中的当前位置。
- 将 `mm` 结构的私有成员指针 `sm_priv` 设为链表头 `pra_list_head`，以便用于后续页面操作和管理。

#### 2. `_clock_map_swappable`加入最近访问的可交换页面

`_clock_map_swappable`函数将最近访问的页面链接到 `pra_list_head` 队列的末尾，并将页面的 `visited` 标志置为1，表示该页面已被访问：

```c
static int
_clock_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)
{
    list_entry_t *entry=&(page->pra_page_link);

    assert(entry != NULL && curr_ptr != NULL);
    //record the page access situlation
    /*LAB3 EXERCISE 4: YOUR CODE*/ 
    // link the most recent arrival page at the back of the pra_list_head qeueue.
    // 将页面page插入到页面链表pra_list_head的末尾
    // 将页面的visited标志置为1，表示该页面已被访问
    list_add_before(&pra_list_head, entry);
    page->visited = 1;
    return 0;
}
```

具体操作如下：

1. 首先获取页面的 `pra_page_link` 指针 `entry`，用于在链表中表示该页面。
2. 使用断言确保 `entry` 和全局指针 `curr_ptr` 不为空。
3. 然后使用了链表插入函数`list_add_before(&pra_list_head, entry)`,将entry插入到链表头的前一个，即插入链表的末尾。
4. 将页面的 `visited` 标志设置为 1，表示页面已被访问。

#### 3. `_clock_swap_out_victim`选择要替换的页面

这个函数是clock页替换算法的核心，实现了选择最早未被访问的页面作为牺牲品被换出，代码如下：

```c
static int
_clock_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick)
{
     list_entry_t *head=(list_entry_t*) mm->sm_priv;
     assert(head != NULL);
     assert(in_tick==0);
     /* Select the victim */
     //(1)  unlink the  earliest arrival page in front of pra_list_head qeueue
     //(2)  set the addr of addr of this page to ptr_page
    while (1) {
        /*LAB3 EXERCISE 4: YOUR CODE*/ 
        // 编写代码
        // 遍历页面链表pra_list_head，查找最早未被访问的页面
        // 获取当前页面对应的Page结构指针
        // 如果当前页面未被访问，则将该页面从页面链表中删除，并将该页面指针赋值给ptr_page作为换出页面
        // 如果当前页面已被访问，则将visited标志置为0，表示该页面已被重新访问
        if(head==list_prev(head))
        {   
            *ptr_page = NULL;
            break;
        }
        if (curr_ptr == &pra_list_head)
        {
            curr_ptr = list_next(curr_ptr);
        }
        struct Page *page = le2page(curr_ptr, pra_page_link);

        if (page->visited == 0)
        {
            cprintf("curr_ptr %p\n", curr_ptr);
            list_del(curr_ptr);

            *ptr_page = page;

            break;
        }
        else
        {
            page->visited = 0;
        }
        curr_ptr = list_next(curr_ptr); 
    }
    return 0;
}
```

主要实现流程为;

1. 获取内存管理结构 `mm` 的私有成员指针 `head`，它指向双向循环链表的头部。使用断言确保 `head` 不为空，并且 `in_tick` 的值为0，表示不处于时钟中断状态。

2. 然后在循环中寻找要替换的页面，利用`curr_ptr`指针进行遍历

   - 如果页面链表为空，将` ptr_page` 设置为 NULL，表示没有要替换的页面

   - 若遍历到链表头部，则从下一个页面继续遍历链表。
   - 若页面的访问位为0，即其最近没有被访问，则将该页面从页面链表中删除，并该页面指针赋值给`ptr_page`作为换出页面。
   - 若页面的访问位为1，即其最近被访问过，则将其访问位设为0。
   - `curr_ptr = list_next(curr_ptr)`继续遍历下一个页面。

### 问题回答

- 比较Clock页替换算法和FIFO算法的不同

1. 替换策略：FIFO是按照页面进入内存的时间来替换页面，替换时选择最早到达的页面换出。而时钟算法则考虑页面的访问情况，选择最早未被访问的页面。
2. 考虑访问情况：时钟算法考虑了页面的访问情况，可以更智能地选择替换页面，避免频繁替换最近访问过的页面，而FIFO不考虑页面的使用频率。
3. 复杂性：时钟算法相对FIFO算法更复杂一些。

### make grade

完成练习的编程后，`make grade` 结果：

![image.png](https://s2.loli.net/2023/10/28/2bgD8sW9M7hxBNz.png)

## 练习五：阅读代码和实现手册，理解页表映射方式相关知识(思考题)

如果我们采用”一个大页“ 的页表映射方式，相比分级页表，有什么好处、优势，有什么坏处、风险？

### 优点：

1. 实现简单，仅需要维护一个页表。
2. 访问速度快，直接访问页表即可，中间无需其他查找操作。

### 缺点：

1. 不能离散存储，必须分配很大的连续的物理内存。但是在系统进行长时间运行之后，由于内存碎片的原因，难以找到很大的连续的物理内存。

2. 浪费内存，不能按需分配页表空间。根据程序的局部性原理可知，进程在运行之后，对内存的访问更倾向于访问最近访问过的数据或者热点数据附近的数据，因此进程真正需要的物理内存其实是很少的一部分，根本不需要一个大页的物理内存来保存映射关系。


## 知识点总结

### 虚拟内存

在操作系统中，虚拟内存其实包含多个虚拟层次，在不同的层次体现了不同的作用。首先，在有了分页机制后，程序员或CPU“看到”的地址已经不是实际的物理地址了，这已经有一层虚拟化，我们可简称为内存地址虚拟化。有了内存地址虚拟化，我们就可以通过设置页表项来限定软件运行时的访问空间，确保软件运行不越界，完成内存访问保护的功能。

通过内存地址虚拟化，可以使得软件在没有访问某虚拟内存地址时不分配具体的物理内存，而只有在实际访问某虚拟内存地址时，操作系统再动态地分配物理内存，建立虚拟内存到物理内存的页映射关系，这种技术称为按需分页（demand paging）。把不经常访问的数据所占的内存空间临时写到硬盘上，这样可以腾出更多的空闲内存空间给经常访问的数据；当CPU访问到不经常访问的数据时，再把这些数据从硬盘读入到内存中，这种技术称为页换入换出（page　swap in/out）。这种内存管理技术给了程序员更大的内存“空间”，从而可以让更多的程序在内存中并发运行。

对应于OS基本知识点：

![image.png](https://s2.loli.net/2023/10/28/nOiCkcEwhSelHNW.png)

### 页面置换

由于操作系统给用户态的应用程序提供了一个虚拟的“大容量”内存空间，而实际的物理内存空间又没有那么大。所以操作系统就就“瞒着”应用程序，只把应用程序中“常用”的数据和代码放在物理内存中，而不常用的数据和代码放在了硬盘这样的存储介质上。如果应用程序访问的是“常用”的数据和代码，那么操作系统已经放置在内存中了，不会出现什么问题。但当应用程序访问它认为应该在内存中的的数据或代码时，如果这些数据或代码不在内存中，则会产生页访问异常。这时，操作系统必须能够应对这种页访问异常，即尽快把应用程序当前需要的数据或代码放到内存中来，然后重新执行应用程序产生异常的访存指令。如果在把硬盘中对应的数据或代码调入内存前，操作系统发现物理内存已经没有空闲空间了，这时操作系统必须把它认为“不常用”的页换出到磁盘上去，以腾出内存空闲空间给应用程序所需的数据或代码。

操作系统迟早会碰到没有内存空闲空间而必须要置换出内存中某个“不常用”的页的情况。如何判断内存中哪些是“常用”的页，哪些是“不常用”的页，把“常用”的页保持在内存中，在物理内存空闲空间不够的情况下，把“不常用”的页置换到硬盘上就是页替换算法着重考虑的问题。容易理解，一个好的页替换算法会导致页访问异常次数少，也就意味着访问硬盘的次数也少，从而使得应用程序执行的效率就高。

#### 缺页异常处理

OS知识点中缺页异常处理的流程：

1. 在内存中有空闲物理页面时，分配一物理页帧f，转第5步；
2. 如果没有空闲物理页面，依据页面置换算法选择将被替换的物理页帧f，对应虚拟页q
3. 如q被修改过，则把它写回外存；
4. 修改q的页表项中驻留位置为0；
5. 将需要访问的页p装入到物理页面f
6. 修改p的页表项驻留位为1，物理页帧号为f；
7. 重新执行产生缺页的指令

#### 页面置换算法

- 先进先出(First In First Out, FIFO)页替换算法：该算法总是淘汰最先进入内存的页，即选择在内存中驻留时间最久的页予以淘汰。只需把一个应用程序在执行过程中已调入内存的页按先后次序链接成一个队列，队列头指向内存中驻留时间最久的页，队列尾指向最近被调入内存的页。这样需要淘汰页时，从队列头很容易查找到需要淘汰的页。FIFO 算法只是在应用程序按线性顺序访问地址空间时效果才好，否则效率不高。因为那些常被访问的页，往往在内存中也停留得最久，结果它们因变“老”而不得不被置换出去。FIFO 算法的另一个缺点是，它有一种异常现象（Belady 现象），即在增加放置页的物理页帧的情况下，反而使页访问异常次数增多。
- 最久未使用(least recently used, LRU)算法：利用局部性，通过过去的访问情况预测未来的访问情况，我们可以认为最近还被访问过的页面将来被访问的可能性大，而很久没访问过的页面将来不太可能被访问。于是我们比较当前内存里的页面最近一次被访问的时间，把上一次访问时间离现在最久的页面置换出去。
- 时钟（Clock）页替换算法：是 LRU 算法的一种近似实现。时钟页替换算法把各个页面组织成环形链表的形式，类似于一个钟的表面。然后把一个指针（简称当前指针）指向最老的那个页面，即最先进来的那个页面。另外，时钟算法需要在页表项（PTE）中设置了一位访问位来表示此页表项对应的页当前是否被访问过。当该页被访问时，CPU 中的 MMU 硬件将把访问位置“1”。当操作系统需要淘汰页时，对当前指针指向的页所对应的页表项进行查询，如果访问位为“0”，则淘汰该页，如果该页被写过，则还要把它换出到硬盘上；如果访问位为“1”，则将该页表项的此位置“0”，继续访问下一个页。该算法近似地体现了 LRU 的思想，且易于实现，开销少，需要硬件支持来设置访问位。时钟页替换算法在本质上与 FIFO 算法是类似的，不同之处是在时钟页替换算法中跳过了访问位为 1 的页。
- 改进的时钟（Enhanced Clock）页替换算法：在时钟置换算法中，淘汰一个页面时只考虑了页面是否被访问过，但在实际情况中，还应考虑被淘汰的页面是否被修改过。因为淘汰修改过的页面还需要写回硬盘，使得其置换代价大于未修改过的页面，所以优先淘汰没有修改的页，减少磁盘操作次数。改进的时钟置换算法除了考虑页面的访问情况，还需考虑页面的修改情况。即该算法不但希望淘汰的页面是最近未使用的页，而且还希望被淘汰的页是在主存驻留期间其页面内容未被修改过的。这需要为每一页的对应页表项内容中增加一位引用位和一位修改位。当该页被访问时，CPU 中的 MMU 硬件将把访问位置“1”。当该页被“写”时，CPU 中的 MMU 硬件将把修改位置“1”。这样这两位就存在四种可能的组合情况：（0，0）表示最近未被引用也未被修改，首先选择此页淘汰；（0，1）最近未被使用，但被修改，其次选择；（1，0）最近使用而未修改，再次选择；（1，1）最近使用且修改，最后选择。该算法与时钟算法相比，可进一步减少磁盘的 I/O 操作次数，但为了查找到一个尽可能适合淘汰的页面，可能需要经过多次扫描，增加了算法本身的执行开销。

实验中涉及的都是局部页面置换算法，在OS课程中还介绍了全局页面置换算法。

局部置换算法没有考虑到进程的访存差异，全局置换算法为进程**<u>分配可变数目的物理页面</u>**

- 进程在不同阶段的内存需求是变化的

- 分配给进程的内存也需要在不同阶段有所变化

- 全局置换算法需要确定分配给进程的物理页面数

全局置换算法包括工作集置换算法和缺页率置换算法。

**工作集置换算法**：

- 思路：**<u>换出不在工作集</u>**中的页面
- 当前时刻前τ个内存访问的页引用是工作集，τ被称为窗口大小
- 访存链表：维护窗口内的访存页面链表
- 访存时，换出不在工作集的页面；更新访存链表
- 缺页时，换入页面；更新访存链表

**缺页率置换算法**：

- 访存时，设置引用位标志

- 缺页时，计算从上次缺页时间tlast 到现在tcurrent 的时间间隔

  - 如果 tcurrent – tlast>T, 则置换所有在[tlast ,  tcurrent ]时间内没有被引用的页

  - 如果tcurrent – tlast ≤ T, 则增加缺失页到工作集中
